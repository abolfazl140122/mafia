<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>بازی معامله‌گر - دوراهی زندانی (نسخه با ربات)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* === همون استایل صفحه‌ی قبلی (مختصر) === */
        :root{--primary-gold:#ffc947;--dark-red:#8c4843;--darker-red:#5a2c2a;--text-light:#f0e6d2;--text-secondary:#c5a687;--bg-dark:#121212;--bg-surface:#1e1e1e;--border-color:#4a4a4a;--green-cooperate:#2ecc71;--red-betray:#e74c3c;--blue-accent:#3498db}
        *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
        html,body{height:100%;width:100%;overflow:hidden}
        body{font-family:'Vazirmatn',sans-serif;color:var(--text-light);background-color:var(--bg-dark);display:flex;justify-content:center;align-items:center;padding:10px}
        #loading-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:var(--bg-dark);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:2000;transition:opacity .5s}
        .loader{border:6px solid #f3f3f330;border-top:6px solid var(--primary-gold);border-radius:50%;width:60px;height:60px;animation:spin 1.5s linear infinite}
        @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
        .game-wrapper{width:100%;height:100%;max-width:1200px;display:grid;grid-template-columns:280px 1fr;grid-template-rows:60px 1fr;grid-template-areas:"header header" "sidebar main";gap:15px;opacity:0;transition:opacity .5s}
        .game-wrapper.visible{opacity:1}
        .game-header{grid-area:header;display:flex;justify-content:space-between;align-items:center;padding:0 20px;background-color:var(--bg-surface);border-radius:12px;border:1px solid var(--border-color)}
        .players-sidebar{grid-area:sidebar;background-color:var(--bg-surface);border-radius:12px;border:1px solid var(--border-color);display:flex;flex-direction:column;overflow:hidden}
        .sidebar-title{padding:15px;font-size:1.2rem;font-weight:700;text-align:center;color:var(--primary-gold);border-bottom:1px solid var(--border-color)}
        #players-list{flex-grow:1;overflow-y:auto;padding:10px}
        .player-score-item{display:flex;align-items:center;justify-content:space-between;padding:12px 10px;border-radius:8px;transition:background-color .2s}
        .player-info{display:flex;align-items:center;gap:10px}
        .player-avatar{width:40px;height:40px;border-radius:50%;object-fit:cover;border:2px solid var(--text-secondary)}
        .player-name{font-weight:700;font-size:1rem}
        .player-score{font-size:1.2rem;font-weight:900;color:var(--primary-gold)}
        .bot-badge{font-size:.8rem;color:#111;background:#ffc; padding:4px 8px;border-radius:12px;font-weight:700}
        .main-content{grid-area:main;background-color:var(--bg-surface);border-radius:12px;border:1px solid var(--border-color);display:flex;flex-direction:column;overflow:hidden;position:relative}
        .overlay-panel{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.85);backdrop-filter:blur(8px);display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:100;opacity:0;visibility:hidden;transition:opacity .5s,visibility .5s}
        .overlay-panel.visible{opacity:1;visibility:visible}
        .choice-buttons{display:flex;gap:20px}
        .choice-btn{padding:15px 40px;font-size:1.5rem;font-weight:900;border-radius:12px;border:3px solid;cursor:pointer;transition:transform .2s,min-width .2s}
        #cooperate-btn{background-color:var(--green-cooperate);border-color:#58d68d;color:white}
        #betray-btn{background-color:var(--red-betray);border-color:#ec7063;color:white}
        #chat-messages{flex-grow:1;overflow-y:auto;padding:15px;display:flex;flex-direction:column;gap:12px}
        #chat-form{display:flex;padding:10px;border-top:1px solid var(--border-color);gap:10px}
        #chat-input{flex-grow:1;background-color:#3a3a3c;border:1px solid var(--border-color);border-radius:20px;padding:10px 15px;color:var(--text-light)}
        #chat-send-btn{background-color:var(--primary-gold);border:none;border-radius:50%;color:var(--bg-dark);font-weight:900;width:45px;height:45px;cursor:pointer;display:flex;justify-content:center;align-items:center}
        @media (max-width:768px){.game-wrapper{grid-template-columns:1fr;grid-template-rows:60px 180px 1fr;grid-template-areas:"header" "sidebar" "main";gap:10px}}
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="loader"></div>
        <p id="loading-text">در حال اتصال به سرور...</p>
    </div>

    <div class="game-wrapper" id="game-wrapper">
        <header class="game-header">
            <h1 id="game-round-info">دور ۱ - شروع</h1>
            <div id="game-timer">00:00</div>
        </header>

        <aside class="players-sidebar">
            <h2 class="sidebar-title">امتیازات (فقط بازیکنان لابی)</h2>
            <div id="players-list"></div>
        </aside>

        <main class="main-content">
            <div id="choice-panel" class="overlay-panel">
                <div class="overlay-content">
                    <h2 class="overlay-title">انتخاب کنید</h2>
                    <p class="overlay-subtitle">آیا به هم‌پیمان خود اعتماد می‌کنید یا به او خیانت خواهید کرد؟</p>
                    <div class="choice-buttons">
                        <button id="cooperate-btn" class="choice-btn">همکاری</button>
                        <button id="betray-btn" class="choice-btn">خیانت</button>
                    </div>
                </div>
            </div>

            <div id="chat-messages"></div>
            <form id="chat-form" action="javascript:void(0);">
                <input type="text" id="chat-input" placeholder="پیام خود را بنویسید..." autocomplete="off" disabled>
                <button type="submit" id="chat-send-btn" disabled>
                    <svg fill="currentColor" width="24" height="24" viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                </button>
            </form>
        </main>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getFirestore, doc, onSnapshot, updateDoc, setDoc, getDoc, collection, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";

        // === پیکربندی فایربیس (مثل قبل) ===
        const firebaseConfig = {
            apiKey: "AIzaSyADQNadPyy43TmSR2yCiKjoLBVMeAqT4Zg",
            authDomain: "mafia-9fcbf.firebaseapp.com",
            databaseURL: "https://mafia-9fcbf-default-rtdb.firebaseio.com",
            projectId: "mafia-9fcbf",
            storageBucket: "mafia-9fcbf.firebasestorage.app",
            messagingSenderId: "471627157488",
            appId: "1:471627157488:web:92f008548a5596619a5735",
            measurementId: "G-0PDHDWC6NV"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // DOM
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const gameWrapper = document.getElementById('game-wrapper');
        const roundInfoEl = document.getElementById('game-round-info');
        const timerEl = document.getElementById('game-timer');
        const playersListEl = document.getElementById('players-list');
        const chatMessagesEl = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatSendBtn = document.getElementById('chat-send-btn');
        const chatForm = document.getElementById('chat-form');
        const choicePanel = document.getElementById('choice-panel');
        const cooperateBtn = document.getElementById('cooperate-btn');
        const betrayBtn = document.getElementById('betray-btn');

        // وضعیت
        let currentGameState = {};
        let currentUser = null;
        let gameId = "active_game_01"; // میتوانید داینامیک کنید
        let gameRef = null;
        let unsubscribeGame = null;
        let timerInterval = null;

        // توجه: اکنون صفحه فقط بازیکنان لابی را بارگزاری می‌کند و لیست کامل users را نخواهد خواند
        // ساختار پیشنهادی کالکشن لابی در فایربیس:
        // collection: lobbies -> doc: <gameId> -> collection: players -> doc: <uid>
        // هر سند پلیر می‌تواند این فیلدها را داشته باشد: displayName, avatarUrl, isBot (boolean), uid

        // === ورود/شروع ===
        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                loadingText.textContent = 'لطفا وارد شوید.';
                return;
            }
            loadingText.textContent = 'در حال دریافت اطلاعات کاربر...';
            const uDoc = await getDoc(doc(db, 'users', user.uid));
            if (!uDoc.exists()) {
                // اگر اطلاعات کاربر موجود نبود، از اطلاعات auth استفاده کن
                currentUser = { uid: user.uid, displayName: user.displayName || 'بدون نام', avatarUrl: user.photoURL || `https://i.pravatar.cc/150?u=${user.uid}` };
            } else {
                currentUser = { uid: user.uid, ...uDoc.data() };
            }

            loadingText.textContent = 'در حال پیوستن به بازی...';
            await initializeGame();
        });

        async function initializeGame(){
            gameRef = doc(db, 'games', gameId);
            const gameSnap = await getDoc(gameRef);

            // اگر بازی موجود نبود، آن را می‌سازیم؛ اما برای لیست بازیکنان از لابی می‌آوریم
            if (!gameSnap.exists()){
                loadingText.textContent = 'در حال ساخت بازی از بازیکنان لابی...';
                await createNewGameFromLobby();
            }

            // گوش دادن به تغییرات بازی
            unsubscribeGame = onSnapshot(gameRef, (docSnap)=>{
                if (!docSnap.exists()) return;
                handleGameStateChange(docSnap.data());
            });

            // نمایش رابط
            loadingOverlay.style.opacity = '0';
            setTimeout(()=>{ loadingOverlay.style.display = 'none'; gameWrapper.classList.add('visible'); }, 500);
        }

        async function createNewGameFromLobby(){
            // خواندن لیست بازیکنان حاضر در لابی
            const lobbyPlayersCol = collection(db, 'lobbies', gameId, 'players');
            const lobbySnap = await getDocs(lobbyPlayersCol);
            let players = [];
            lobbySnap.forEach(d => {
                const data = d.data();
                players.push({
                    uid: d.id,
                    displayName: data.isBot ? (data.displayName || 'ربات') : (data.displayName || 'بدون نام'),
                    avatarUrl: data.avatarUrl || `https://i.pravatar.cc/150?u=${d.id}`,
                    score: data.score || 0,
                    isBot: !!data.isBot
                });
            });

            // اگر لابی خالی بود، فقط کاربر فعلی را اضافه کن (fallback)
            if (players.length === 0){
                players.push({ uid: currentUser.uid, displayName: currentUser.displayName, avatarUrl: currentUser.avatarUrl, score: 0, isBot: false });
            }

            const initialGameState = {
                round: 1,
                phase: 'initial',
                players: players,
                pairs: [],
                choices: {},
                chat: []
            };

            await setDoc(gameRef, initialGameState);
            await addAnnouncementMessage('راوی: بازی از روی بازیکنان لابی ساخته شد.');

            // شروع بازی پس از کوتاهی
            setTimeout(startGame, 1500);
        }

        function handleGameStateChange(state){
            if (!state) return;
            currentGameState = state;
            renderUI(state);
            handleGamePhase(state);
        }

        function renderUI(state){
            // نمایش فقط بازیکنان حاضر در state.players (که از لابی آمده‌اند)
            playersListEl.innerHTML = '';
            if (!state.players) return;

            [...state.players].sort((a,b)=>b.score-a.score).forEach(p=>{
                const isSelf = p.uid === currentUser.uid;
                const el = document.createElement('div');
                el.className = 'player-score-item';
                el.innerHTML = `
                    <div class="player-info">
                        <img src="${p.avatarUrl}" class="player-avatar" alt="${p.displayName}">
                        <div style="display:flex;flex-direction:column;align-items:flex-end">
                            <span class="player-name">${p.isBot ? 'ربات' : escapeHtml(p.displayName)}</span>
                            ${p.isBot ? '<span class="bot-badge">ربات</span>' : ''}
                        </div>
                    </div>
                    <span class="player-score">${p.score}</span>
                `;
                if (isSelf) el.style.borderLeft = '4px solid var(--primary-gold)';
                playersListEl.appendChild(el);
            });

            // رندر چت
            chatMessagesEl.innerHTML = '';
            if (state.chat && Array.isArray(state.chat)){
                state.chat.forEach(m => { addMessageToChatUI(m); });
            }
        }

        function handleGamePhase(state){
            const myPair = state.pairs ? state.pairs.find(p => p.includes(currentUser.uid)) : null;
            choicePanel.classList.remove('visible');
            enableChat(false, true);

            switch(state.phase){
                case 'pairing':
                    roundInfoEl.textContent = `دور ${state.round} - هم‌پیمانی`;
                    if (myPair) showPairingPanel(myPair);
                    break;
                case 'choice':
                    roundInfoEl.textContent = `دور ${state.round} - انتخاب`;
                    // بوت‌ها در اینجا خودشون تصمیم می‌گیرند (سیستم خودکار)
                    autoDecideBots();
                    // اگر من هنوز انتخاب نکرده‌ام و من آدم واقعی هستم، پنل انتخاب را نشان بده
                    if (myPair && !currentGameState.choices[currentUser.uid] && !isCurrentUserBot()){
                        showChoicePanel();
                    }
                    break;
                case 'public_chat':
                    roundInfoEl.textContent = `دور ${state.round} - چت عمومی`;
                    enableChat(false);
                    break;
                case 'private_chat':
                    roundInfoEl.textContent = `دور ${state.round} - چت خصوصی`;
                    enableChat(true);
                    break;
                case 'results':
                    roundInfoEl.textContent = `دور ${state.round} - نتایج`;
                    computeResults();
                    break;
                default:
                    roundInfoEl.textContent = `دور ${state.round} - در انتظار...`;
            }
        }

        function isCurrentUserBot(){
            const me = (currentGameState.players||[]).find(p=>p.uid===currentUser.uid);
            return me ? !!me.isBot : false;
        }

        // نمایش پنل همپیمانی (ساده)
        function showPairingPanel(pair){
            const partnerId = pair.find(id=>id!==currentUser.uid);
            const partner = (currentGameState.players||[]).find(p=>p.uid===partnerId);
            // اگر هم‌پیمان بوت است، نام 'ربات' نمایش داده می‌شود
            // ما از یک پنل ساده استفاده می‌کنیم: همان پنلی که داشتیم، اما اینجا به‌صورت خلاصه
            // (برای کوتاهی اینجا فقط اعلان می‌گذاریم)
            addAnnouncementMessage(`راوی: هم‌پیمان شما ${partner ? (partner.isBot ? 'ربات' : partner.displayName) : '...'} است.`);
        }

        // پنل انتخاب برای بازیکن واقعی
        function showChoicePanel(){
            cooperateBtn.classList.remove('selected');
            betrayBtn.classList.remove('selected');
            choicePanel.classList.add('visible');
        }

        // === منطق ربات‌ها: تصمیم‌گیری خودکار ===
        // الگوریتم پیشنهادی: ترکیب استراتژی‌های ساده مانند "گرایش به خیانت با احتمال X" و "تقلید از تصمیمات گذشته هم‌پیمان"
        async function autoDecideBots(){
            if (!currentGameState || !currentGameState.pairs) return;

            // اگر قبلا همه انتخاب‌ها انجام شده‌اند، کاری نکن
            const totalPlayersInPairs = currentGameState.pairs.flat().length;
            const existingChoicesCount = Object.keys(currentGameState.choices || {}).length;
            if (existingChoicesCount >= totalPlayersInPairs) return;

            let choices = {...(currentGameState.choices || {})};
            let changed = false;

            // هر جفت را بررسی کن و برای هر بوت تصمیم بگیر اگر هنوز انتخاب نکرده
            for (const pair of currentGameState.pairs){
                for (const uid of pair){
                    const player = (currentGameState.players||[]).find(p=>p.uid===uid);
                    if (!player) continue;
                    if (!player.isBot) continue; // فقط برای ربات‌ها تصمیم بگیر
                    if (choices[uid]) continue; // اگر قبلا انتخاب کرده، رد کن

                    // تصمیم‌گیری ربات: مثال ساده و قابل تغییر
                    // 1) اگر هم‌پیمان قبلا در راندهای قبل خیانت کرده باشد، احتمال خیانت افزایش می‌یابد
                    // 2) در غیر این صورت، ربات با احتمال پیش‌فرض همکاری می‌کند

                    const partnerId = pair.find(id=>id!==uid);
                    const partnerChoiceHistory = getPartnerHistory(partnerId);

                    // پایه احتمال همکاری
                    let coopProb = 0.6;
                    // اگر در تاریخچه هم‌پیمان درصد خیانت بالا باشد، coopProb کاهش می‌یابد
                    if (partnerChoiceHistory.total > 0){
                        const betrayRate = partnerChoiceHistory.betray / partnerChoiceHistory.total;
                        // اگر هم‌پیمان معمولاً خیانت کرده، این ربات هم احتمالاً خیانت می‌کند
                        coopProb = Math.max(0.1, 0.85 - betrayRate * 0.8);
                    }

                    // به صورت تصادفی تصمیم بگیر
                    const rand = Math.random();
                    const finalChoice = rand < coopProb ? 'cooperate' : 'betray';

                    choices[uid] = finalChoice;
                    changed = true;
                    await addAnnouncementMessage(`راوی: یک ربات تصمیم خود را گرفت (${finalChoice === 'cooperate' ? 'همکاری' : 'خیانت'}).`);
                }
            }

            if (changed){
                // به‌روز‌رسانی دیتابیس با choices جدید
                await updateDoc(gameRef, { choices });
                // پس از به‌روز‌رسانی، چک کن آیا همه انتخاب‌ها انجام شده
                checkAllChoicesMade();
            }
        }

        // گرفتن تاریخچه خیلی ساده از choices در راندهای قبل (اگر نگهداری نشده باشد، از currentGameState استفاده می‌کنیم)
        function getPartnerHistory(partnerId){
            // اگر در دیتابیس تنها choices این راند ذخیره می‌شود، تاریخچه نداریم.
            // برای نمونه، این تابع فقط از currentGameState.choices همین بازی استفاده می‌کند.
            let betray = 0, total = 0;
            const choicesHistory = currentGameState.choicesHistory || {}; // اگر داشتیست
            if (choicesHistory[partnerId]){
                choicesHistory[partnerId].forEach(c => { if (c === 'betray') betray++; total++; });
            }
            // fallback: اگر تاریخی موجود نیست، برگرد عدد صفر
            return { betray, total };
        }

        // بررسی اینکه آیا همه انتخاب‌ها انجام شده‌اند
        async function checkAllChoicesMade(){
            const pairedPlayersCount = currentGameState.pairs.flat().length;
            const totalChoices = Object.keys(currentGameState.choices || {}).length;
            if (totalChoices >= pairedPlayersCount){
                await addAnnouncementMessage('راوی: تصمیم‌گیری‌ها انجام شد. انتقال به چت عمومی...');
                setTimeout(startPublicChatPhase, 1200);
            }
        }

        // === جریان بازی (همانند قبل ولی با فراخوانی‌های لازم برای ربات‌ها) ===
        async function startGame(){
            if (!currentGameState.players || currentGameState.players.length === 0) return;
            await addAnnouncementMessage('راوی: گروه‌بندی در حال انجام است...');

            let playersToPair = [...currentGameState.players];
            playersToPair.sort(() => Math.random() - 0.5);
            let pairs = [];
            while(playersToPair.length > 1){
                const p1 = playersToPair.pop();
                const p2 = playersToPair.pop();
                pairs.push([p1.uid, p2.uid]);
            }
            // اگر فردی تنها ماند، او را با خود شبیه‌سازی کن (یا به حالت ناظر بفرست)
            if (playersToPair.length === 1){
                const last = playersToPair.pop();
                pairs.push([last.uid, last.uid]);
            }

            await updateDoc(gameRef, { phase: 'pairing', pairs: pairs, choices: {} });

            // بعد از چند ثانیه وارد فاز انتخاب شو
            setTimeout(async ()=>{ await updateDoc(gameRef, { phase: 'choice' }); }, 3000);
        }

        async function startPublicChatPhase(){
            await updateDoc(gameRef, { phase: 'public_chat' });
            await addAnnouncementMessage('چت عمومی فعال شد. شما 90 ثانیه فرصت دارید.');
            startTimer(90, startPrivateChatPhase);
        }

        async function startPrivateChatPhase(){
            await updateDoc(gameRef, { phase: 'private_chat' });
            await addAnnouncementMessage('چت خصوصی فعال شد. 60 ثانیه فرصت دارید.');
            startTimer(60, endRound);
        }

        async function endRound(){
            await updateDoc(gameRef, { phase: 'results' });
            await addAnnouncementMessage('زمان این دور به پایان رسید. در حال محاسبه نتایج...');
            // محاسبه امتیازها به صورت ساده: هر همکاری 3 امتیاز، خیانت به هم‌پیمان 5 امتیاز و غیره — شما می‌توانید آن را به نیاز خود تغییر دهید
            computeResults();
        }

        async function computeResults(){
            // محاسبه ساده
            const pairs = currentGameState.pairs || [];
            const playersMap = {};
            (currentGameState.players || []).forEach(p=> playersMap[p.uid] = { ...p });

            for (const pair of pairs){
                const [a,b] = pair;
                const choiceA = (currentGameState.choices || {})[a] || 'cooperate';
                const choiceB = (currentGameState.choices || {})[b] || 'cooperate';

                if (choiceA === 'cooperate' && choiceB === 'cooperate'){
                    playersMap[a].score += 3;
                    playersMap[b].score += 3;
                } else if (choiceA === 'betray' && choiceB === 'cooperate'){
                    playersMap[a].score += 5;
                    playersMap[b].score += 0;
                } else if (choiceA === 'cooperate' && choiceB === 'betray'){
                    playersMap[a].score += 0;
                    playersMap[b].score += 5;
                } else { // both betray
                    playersMap[a].score += 1;
                    playersMap[b].score += 1;
                }
            }

            const updatedPlayers = Object.values(playersMap);
            await updateDoc(gameRef, { players: updatedPlayers });
            await addAnnouncementMessage('راوی: امتیازات بروزرسانی شد.');

            // آماده سازی برای راند بعدی
            setTimeout(async ()=>{
                const nextRound = (currentGameState.round || 1) + 1;
                await updateDoc(gameRef, { round: nextRound, phase: 'pairing', pairs: [], choices: {} });
                setTimeout(startGame, 1000);
            }, 2000);
        }

        // === چت و UI helpers ===
        function enableChat(isPrivate, isDisabled=false){
            chatInput.disabled = isDisabled;
            chatSendBtn.disabled = isDisabled;
            chatInput.placeholder = isDisabled ? 'چت غیرفعال است' : (isPrivate ? 'با هم‌پیمان خود چت کنید...' : 'با همه صحبت کنید...');
        }

        chatForm.addEventListener('submit', handleSendMessage);

        async function handleSendMessage(e){
            e.preventDefault();
            const text = chatInput.value.trim();
            if (!text) return;
            const isPrivate = currentGameState.phase === 'private_chat';
            const newMessage = { senderUid: currentUser.uid, senderName: currentUser.displayName, senderAvatar: currentUser.avatarUrl, text, isPrivate, timestamp: new Date() };
            const newChat = [...(currentGameState.chat||[]), newMessage];
            await updateDoc(gameRef, { chat: newChat });
            chatInput.value = '';
        }

        function addMessageToChatUI(msg){
            if (!msg) return;
            if (msg.announcement){
                const el = document.createElement('div'); el.className = 'chat-message announcement'; el.textContent = msg.text; chatMessagesEl.appendChild(el); chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight; return;
            }
            // پیام خصوصی فقط برای هم‌پیمان نمایش داده می‌شود
            if (msg.isPrivate){
                const myPair = currentGameState.pairs ? currentGameState.pairs.find(p=>p.includes(currentUser.uid)) : null;
                if (!myPair || !myPair.includes(msg.senderUid)) return;
            }
            const el = document.createElement('div'); el.className = 'chat-message';
            el.innerHTML = `\n                <img src="${msg.senderAvatar}" class="chat-message-avatar">\n                <div class="chat-message-content">\n                    <span class="chat-message-sender">${msg.senderName}</span>\n                    <div class="chat-message-bubble">${escapeHtml(msg.text)}</div>\n                </div>`;
            chatMessagesEl.appendChild(el); chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
        }

        async function addAnnouncementMessage(text){
            const newMessage = { announcement: true, text, timestamp: new Date() };
            const newChat = [...(currentGameState.chat||[]), newMessage];
            // اگر gameRef هنوز ساخته نشده بود، نریزش کن
            if (!gameRef) return;
            await updateDoc(gameRef, { chat: newChat });
        }

        // حفاظت ابتدایی از XSS در نمایش
        function escapeHtml(text){
            if (!text) return '';
            return String(text).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'","&#039;");
        }

        // === دکمه‌های انتخاب توسط بازیکن واقعی ===
        cooperateBtn.addEventListener('click', async ()=>{
            await handlePlayerChoice('cooperate');
        });
        betrayBtn.addEventListener('click', async ()=>{
            await handlePlayerChoice('betray');
        });

        async function handlePlayerChoice(choice){
            // اگر کاربر فعلی ربات باشد، اجازه نده (ربات‌ها از قبل تصمیم می‌گیرند)
            if (isCurrentUserBot()) return;
            cooperateBtn.classList.add('selected'); betrayBtn.classList.add('selected');
            await addAnnouncementMessage(`شما "${choice === 'cooperate' ? 'همکاری' : 'خیانت'}" را انتخاب کردید.`);
            const choices = {...(currentGameState.choices||{})};
            choices[currentUser.uid] = choice;
            await updateDoc(gameRef, { choices });
            checkAllChoicesMade();
            choicePanel.classList.remove('visible');
        }

        // تایمر ساده
        function startTimer(duration, onComplete){
            if (timerInterval) clearInterval(timerInterval);
            let timeLeft = duration; const endTime = Date.now() + duration*1000;
            timerInterval = setInterval(()=>{
                timeLeft = Math.round((endTime - Date.now())/1000);
                timerEl.textContent = formatTime(timeLeft);
                if (timeLeft <= 0){ clearInterval(timerInterval); timerEl.textContent = '00:00'; if (onComplete) onComplete(); }
            },1000);
        }
        function formatTime(s){ const m=Math.floor(s/60); const sec=s%60; return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`; }

        // محافظت در زمان خروج — قطع شنونده
        window.addEventListener('beforeunload', ()=>{ if (unsubscribeGame) unsubscribeGame(); });

        // پایان
    </script>
</body>
</html>
