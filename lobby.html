<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>لابی بازی - شهر مافیا</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-gold: #ffc947;
            --dark-red: #8c4843;
            --darker-red: #5a2c2a;
            --text-light: #f0e6d2;
            --text-secondary: #c5a687;
            --bg-dark: #1a140e;
            --border-color: #5c4a3a;
            --green-ready: #2ecc71;
            --red-kick: #e74c3c;
            --mic-active: #3498db;
            --slot-bg: linear-gradient(160deg, #2a2118, var(--bg-dark));
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        html, body { height: 100%; overflow: hidden; background-color: var(--bg-dark); }

        body {
            font-family: 'Vazirmatn', sans-serif;
            color: var(--text-light);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #background-blurry {
            position: fixed; top: -20px; left: -20px; width: calc(100% + 40px); height: calc(100% + 40px);
            background-image: url('https://up.20script.ir/file/6195-file-000000001500622f9419de6c322df297-1-.jpg');
            background-size: cover; background-position: center center; filter: blur(8px) brightness(0.6); z-index: -1;
        }
        
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 2000; transition: opacity 0.5s ease;
        }
        .loader {
            border: 6px solid #f3f3f330; border-top: 6px solid var(--primary-gold);
            border-radius: 50%; width: 60px; height: 60px; animation: spin 1.5s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #loading-text { margin-top: 20px; font-size: 1.1rem; font-weight: 700; }

        .lobby-container {
            width: 100%; height: 100%; display: flex; flex-direction: column;
            padding: 10px; gap: 10px;
        }

        .lobby-header { 
            flex-shrink: 0;
            display: flex; justify-content: space-between; align-items: center;
            background-color: rgba(0,0,0,0.4); padding: 8px 12px; border-radius: 12px; border: 1px solid var(--border-color);
        }
        #lobby-name { font-size: 1.3rem; font-weight: 900; color: var(--primary-gold); text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
        .leave-button {
            background: linear-gradient(145deg, #a13d3d, #7c1f1f); border: 1px solid #ff8f8f;
            color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700; font-size: 0.9rem; cursor: pointer; transition: all 0.2s ease;
        }
        .leave-button:hover { transform: scale(1.05); box-shadow: 0 2px 10px rgba(0,0,0,0.4); }

        .players-area {
            flex-grow: 1; display: grid; grid-template-columns: 1fr 1fr;
            gap: 10px; padding: 0 5px; overflow: hidden;
        }
        .players-column { display: flex; flex-direction: column; gap: 8px; height: 100%; }
        
        @keyframes slot-fade-in { 
            from { opacity: 0; transform: translateY(15px) scale(0.9); } 
            to { opacity: 1; transform: translateY(0) scale(1); } 
        }

        .player-slot {
            flex: 1; border-radius: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 5px; text-align: center; transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            position: relative; overflow: hidden; animation: slot-fade-in 0.6s cubic-bezier(0.25, 0.8, 0.25, 1) forwards; min-height: 0;
        }
        .player-slot.empty {
            background: rgba(0,0,0,0.2); border: 2px dashed var(--border-color); opacity: 0.7;
            backdrop-filter: blur(2px); cursor: default;
        }
        .player-slot.filled {
            background: var(--slot-bg); border: 2px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.3);
        }
        .player-avatar {
            width: 55%; max-width: 70px; aspect-ratio: 1/1; border-radius: 50%; object-fit: cover;
            border: 3px solid var(--text-secondary); margin-bottom: 5px; transition: all 0.3s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.5);
        }
        .player-name { 
            font-size: clamp(0.65rem, 2.2vw, 0.8rem); font-weight: 700; width: 100%; white-space: normal;
            word-break: break-word; line-height: 1.2; padding: 0 2px; text-shadow: 0 1px 3px #000;
            height: 2.5em; display: flex; align-items: center; justify-content: center;
        }
        .empty-text { font-size: clamp(0.7rem, 2.5vw, 0.8rem); color: var(--text-secondary); font-weight: 700; }
        .host-crown {
            position: absolute; top: -1px; right: -1px; width: 28px; height: 28px; background-color: var(--primary-gold);
            color: var(--darker-red); border-radius: 0 10px 0 10px; display: flex; align-items: center; justify-content: center;
            font-size: 1rem; font-weight: 900; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .ready-indicator {
            position: absolute; bottom: 4px; right: 4px; width: 18px; height: 18px; background-color: var(--green-ready);
            border-radius: 50%; border: 2px solid var(--bg-dark); display: flex; align-items: center; justify-content: center;
            color: white; font-weight: 900; font-size: 0.8rem; transform: scale(0);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); text-shadow: 0 1px 2px rgba(0,0,0,0.4);
        }
        .player-slot.ready .ready-indicator { transform: scale(1); }
        .player-slot.ready .player-avatar { border-color: var(--green-ready); }
        .player-slot.ready {
            border-color: var(--green-ready);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.7), 0 0 25px rgba(46, 204, 113, 0.4), inset 0 0 10px rgba(0,0,0,0.3);
            transform: scale(1.02);
        }
        .player-slot.speaking .player-avatar {
            border-color: var(--mic-active);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.8), 0 3px 8px rgba(0,0,0,0.5);
        }

        /* --- NEW LAYOUT FOR ACTIONS --- */
        .lobby-actions { padding-top: 10px; flex-shrink: 0; display: flex; gap: 10px; align-items: center; }

        .action-button {
            flex-grow: 1; /* Takes up remaining space */
            padding: 14px; font-size: 1.2rem; font-weight: 900;
            border-radius: 12px; border: none; cursor: pointer; transition: all 0.3s ease;
            color: white; text-shadow: 0 2px 4px rgba(0,0,0,0.5); position: relative; overflow: hidden;
        }
        .action-button::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 20%);
            transform: rotate(25deg);
        }
        .action-button.ready-btn { background: linear-gradient(145deg, #27ae60, #229954); border: 2px solid #58d68d; }
        .action-button.unready-btn { background: linear-gradient(145deg, #c0392b, #a93226); border: 2px solid #e67e22; }
        .action-button.start-btn { background: linear-gradient(145deg, var(--dark-red), var(--darker-red)); border: 2px solid var(--primary-gold); }
        .action-button:disabled { background: linear-gradient(145deg, #7f8c8d, #626567); border-color: #95a5a6; cursor: not-allowed; opacity: 0.6; }
        .action-button:not(:disabled):hover { transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }

        /* --- NEW: MICROPHONE BUTTON --- */
        .mic-button {
            flex-shrink: 0; width: 56px; height: 56px; border-radius: 50%;
            border: 2px solid var(--border-color); background: linear-gradient(145deg, #504436, #332a20);
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            transition: all 0.3s ease; position: relative;
        }
        .mic-button:not(:disabled):hover { transform: scale(1.1); border-color: var(--primary-gold); }
        .mic-button:disabled { cursor: not-allowed; opacity: 0.5; background: #626567; }
        .mic-button svg { width: 24px; height: 24px; fill: var(--text-light); transition: fill 0.3s ease; }
        
        /* Mic states */
        .mic-button.mic-on { border-color: var(--mic-active); background: #2980b9; }
        .mic-button.mic-on svg { fill: white; }
        
        .mic-button.mic-speaking::before {
            content: ''; position: absolute; top: -4px; left: -4px; right: -4px; bottom: -4px;
            border-radius: 50%; border: 3px solid var(--mic-active);
            animation: pulse-mic 1.5s infinite;
        }
        
        @keyframes pulse-mic {
            0% { transform: scale(0.95); opacity: 0.7; }
            70% { transform: scale(1.1); opacity: 0; }
            100% { transform: scale(0.95); opacity: 0; }
        }

        /* --- MODAL STYLES --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); backdrop-filter: blur(5px); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0s 0.3s; }
        .modal-overlay.visible { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }
        .modal-content { 
            background: linear-gradient(145deg, #3c3022, var(--bg-dark)); 
            border: 2px solid var(--border-color); border-radius: 16px; 
            padding: 25px; width: 90%; max-width: 380px; text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-title { font-size: 1.5rem; font-weight: 900; color: var(--primary-gold); margin-bottom: 20px; }
        .modal-message { font-size: 1rem; line-height: 1.6; margin-bottom: 25px; }
        .modal-buttons { display: flex; gap: 15px; }
        .modal-button { flex-grow: 1; padding: 12px; font-size: 1rem; font-weight: 700; border-radius: 8px; cursor: pointer; border: 1px solid; }
        .modal-button.primary { color: white; background: linear-gradient(145deg, var(--dark-red), var(--darker-red)); border-color: var(--primary-gold); }
        .modal-button.secondary { color: var(--text-light); background: linear-gradient(145deg, #504436, #332a20); border-color: var(--border-color); }
    </style>
</head>
<body>

    <div id="background-blurry"></div>
    <div id="loading-overlay">
        <div class="loader"></div>
        <p id="loading-text">در حال ورود به لابی...</p>
    </div>

    <div class="lobby-container" style="display: none;">
        <header class="lobby-header">
            <h1 id="lobby-name">نام لابی...</h1>
            <button id="leave-lobby-btn" class="leave-button">خروج</button>
        </header>

        <main class="players-area">
            <div id="left-players" class="players-column"></div>
            <div id="right-players" class="players-column"></div>
        </main>

        <footer class="lobby-actions">
            <button id="action-btn" class="action-button ready-btn">آماده</button>
            <button id="mic-btn" class="mic-button" title="برای صحبت کردن نگه دارید" disabled>
                <!-- SVG Microphone Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M192 0C139 0 96 43 96 96V256c0 53 43 96 96 96s96-43 96-96V96c0-53-43-96-96-96zM64 216c0-21.9-16.1-39.8-35.4-41.6-21.1-2-38.6 15.3-38.6 36.8v5.3c0 78.8 55.8 144.1 128 157.8V480H96c-17.7 0-32 14.3-32 32s14.3 32 32 32h192c17.7 0 32-14.3 32-32s-14.3-32-32-32h-32V424.3c72.2-13.6 128-79 128-157.8v-5.3c0-21.5-17.5-38.8-38.6-36.8C80.1 176.2 64 194.1 64 216z"/></svg>
            </button>
        </footer>
    </div>
    
    <div id="confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="confirm-modal-title" class="modal-title"></h2>
            <p id="confirm-modal-message" class="modal-message"></p>
            <div class="modal-buttons">
                <button id="confirm-modal-yes-btn" class="modal-button primary">بله</button>
                <button id="confirm-modal-no-btn" class="modal-button secondary">خیر</button>
            </div>
        </div>
    </div>
    
    <div id="notification-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="notification-modal-title" class="modal-title">توجه</h2>
            <p id="notification-modal-message" class="modal-message"></p>
            <div class="modal-buttons">
                <button id="notification-modal-ok-btn" class="modal-button primary">متوجه شدم</button>
            </div>
        </div>
    </div>
    
    <!-- Hidden container for remote audio streams -->
    <div id="remote-audios" style="display: none;"></div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, runTransaction, getDoc, collection, addDoc, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        // --- Config & Elements ---
        const MAX_PLAYERS = 12;
        const MIN_PLAYERS_TO_START = 2;
        const firebaseConfig = {
          apiKey: "AIzaSyADQNadPyy43TmSR2yCiKjoLBVMeAqT4Zg",
          authDomain: "mafia-9fcbf.firebaseapp.com",
          projectId: "mafia-9fcbf",
          storageBucket: "mafia-9fcbf.appspot.com",
          messagingSenderId: "471627157488",
          appId: "1:471627157488:web:92f008548a5596619a5735",
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // UI Elements
        const loadingOverlay = document.getElementById('loading-overlay');
        const lobbyContainer = document.querySelector('.lobby-container');
        const lobbyNameEl = document.getElementById('lobby-name');
        const leftPlayersEl = document.getElementById('left-players');
        const rightPlayersEl = document.getElementById('right-players');
        const actionBtn = document.getElementById('action-btn');
        const leaveLobbyBtn = document.getElementById('leave-lobby-btn');
        const micBtn = document.getElementById('mic-btn');
        const remoteAudiosContainer = document.getElementById('remote-audios');

        // State
        let currentUser = null;
        let currentUserData = {};
        let lobbyId = null;
        let unsubscribeLobby = null;
        let isHost = false;
        let isReady = false;
        let lastPlayerCount = 0;
        let currentPlayers = [];

        // --- WebRTC State ---
        let localStream = null;
        let peerConnections = {}; // { uid: RTCPeerConnection }
        let isMicReady = false;
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ],
        };

        // --- Main Logic ---

        function main() {
            lobbyId = new URLSearchParams(window.location.search).get('id');
            if (!lobbyId) {
                showNotificationModal("خطا", "شناسه لابی نامعتبر است.", () => window.location.href = './Lobby page.html');
                return;
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUser = user;
                    const userDocSnap = await getDoc(doc(db, 'users', user.uid));
                    currentUserData = userDocSnap.exists() ? userDocSnap.data() : { displayName: user.displayName, avatarUrl: user.photoURL };
                    await joinLobby();
                    listenToLobbyChanges();
                    setupEventListeners();
                } else {
                    window.location.href = './login.html';
                }
            });
        }

        async function joinLobby() {
            // ... (existing joinLobby logic, unchanged)
        }

        function listenToLobbyChanges() {
            const lobbyDocRef = doc(db, "Lobbys list", lobbyId);
            unsubscribeLobby = onSnapshot(lobbyDocRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showNotificationModal("لابی حذف شد", "این لابی توسط سازنده حذف شده است.", () => cleanupAndRedirect());
                    return;
                }
                const lobbyData = docSnap.data();
                
                renderLobby(lobbyData);
                handlePlayerChanges(lobbyData.players || []);

                if (loadingOverlay.style.display !== 'none') {
                    loadingOverlay.style.opacity = '0';
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                        lobbyContainer.style.display = 'flex';
                    }, 500);
                }
            }, (error) => {
                console.error("Error listening to lobby:", error);
                showNotificationModal("خطای ارتباط", "ارتباط با لابی قطع شد.", () => cleanupAndRedirect());
            });
        }
        
        function renderLobby(data) {
             // ... (existing renderLobby logic, with one minor addition for speaking indicator)
            lobbyNameEl.textContent = data.lobbyName;
            const players = data.players || [];
            isHost = currentUser.uid === data.creatorId;
            leftPlayersEl.innerHTML = '';
            rightPlayersEl.innerHTML = '';
            
            for (let i = 0; i < MAX_PLAYERS; i++) {
                const player = players[i];
                const slot = document.createElement('div');
                slot.className = 'player-slot';
                slot.style.animationDelay = `${(i % 6) * 70}ms`;
                
                if (player) {
                    slot.classList.add('filled');
                    slot.setAttribute('data-uid', player.uid); // Add UID for easy selection
                    // ... rest of the player slot creation
                } else {
                    slot.classList.add('empty');
                    slot.innerHTML = `<span class="empty-text">جایگاه خالی</span>`;
                }
                 if (i < 6) leftPlayersEl.appendChild(slot); else rightPlayersEl.appendChild(slot);
            }
            // ... rest of renderLobby logic
        }

        function setupEventListeners() {
            actionBtn.addEventListener('click', handleActionClick);
            leaveLobbyBtn.addEventListener('click', showLeaveConfirm);
            
            // --- NEW: Mic Button Listeners (Push-to-Talk) ---
            micBtn.addEventListener('click', initMic); // First click initializes
            micBtn.addEventListener('mousedown', () => toggleMic(true));
            micBtn.addEventListener('mouseup', () => toggleMic(false));
            micBtn.addEventListener('mouseleave', () => toggleMic(false)); // If mouse leaves button while pressed
            micBtn.addEventListener('touchstart', (e) => { e.preventDefault(); toggleMic(true); });
            micBtn.addEventListener('touchend', (e) => { e.preventDefault(); toggleMic(false); });
        }
        
        async function handleLeaveLobby(isKicked = false) {
            // ... (updated to handle WebRTC cleanup)
            if (unsubscribeLobby) unsubscribeLobby();
            await cleanupWebRTC(); // Clean up all connections and signals
            
            if (!isKicked) { // Don't run transaction if kicked, as someone else did it
                const lobbyDocRef = doc(db, "Lobbys list", lobbyId);
                try {
                    await runTransaction(db, async (transaction) => {
                        const lobbyDoc = await transaction.get(lobbyDocRef);
                        if (!lobbyDoc.exists()) return;
                        if (isHost) {
                            transaction.delete(lobbyDocRef);
                        } else {
                            let players = lobbyDoc.data().players.filter(p => p.uid !== currentUser.uid);
                            transaction.update(lobbyDocRef, { players: players, playerCount: players.length });
                        }
                    });
                } catch(e) { console.error("Error leaving lobby:", e); }
            }

            window.location.href = './Lobby page.html';
        }

        // --- WebRTC LOGIC ---

        async function initMic() {
            if (isMicReady) return; // Already initialized
            try {
                // IMPORTANT: This requires HTTPS to work on a live server
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isMicReady = true;
                micBtn.classList.add('mic-on');
                micBtn.removeEventListener('click', initMic); // No need for this listener anymore

                // Mute by default, enable only when holding button
                localStream.getAudioTracks()[0].enabled = false;
                
                // Start connection process with existing players
                currentPlayers.forEach(player => {
                    if(player.uid !== currentUser.uid) {
                        createPeerConnection(player.uid, true);
                    }
                });

                // Start listening for signals addressed to us
                listenForSignals();

            } catch (error) {
                console.error("Error accessing microphone:", error);
                showNotificationModal("دسترسی به میکروفون", "برای استفاده از چت صوتی، لطفاً دسترسی به میکروفون را مجاز کنید. اگر دسترسی را رد کرده‌اید، باید آن را از تنظیمات مرورگر خود فعال کنید.");
                micBtn.disabled = true;
            }
        }
        
        function toggleMic(isSpeaking) {
            if (!isMicReady) return;
            if (isSpeaking) {
                micBtn.classList.add('mic-speaking');
                localStream.getAudioTracks()[0].enabled = true;
                // You could also send a firestore update here to show others you're speaking
            } else {
                micBtn.classList.remove('mic-speaking');
                localStream.getAudioTracks()[0].enabled = false;
            }
        }

        function handlePlayerChanges(players) {
            const newPlayerUIDs = new Set(players.map(p => p.uid));
            const oldPlayerUIDs = new Set(currentPlayers.map(p => p.uid));
            
            // New players joined
            for (const player of players) {
                if (!oldPlayerUIDs.has(player.uid) && player.uid !== currentUser.uid) {
                    console.log(`Player ${player.displayName} joined. Initiating connection.`);
                    if (isMicReady) {
                       createPeerConnection(player.uid, true); // I am the initiator
                    }
                }
            }

            // Players left
            for (const oldPlayer of currentPlayers) {
                if (!newPlayerUIDs.has(oldPlayer.uid) && oldPlayer.uid !== currentUser.uid) {
                    console.log(`Player ${oldPlayer.displayName} left. Closing connection.`);
                    if (peerConnections[oldPlayer.uid]) {
                        peerConnections[oldPlayer.uid].close();
                        delete peerConnections[oldPlayer.uid];
                    }
                    const remoteAudio = document.getElementById(`audio-${oldPlayer.uid}`);
                    if (remoteAudio) remoteAudio.remove();
                }
            }
            currentPlayers = players; // Update current player list
        }

        async function createPeerConnection(targetUid, isInitiator) {
            if (peerConnections[targetUid]) return; // Connection already exists
            
            const pc = new RTCPeerConnection(iceServers);
            peerConnections[targetUid] = pc;

            // Add local stream tracks to the connection
            if(localStream) {
               localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }

            pc.onicecandidate = event => {
                if (event.candidate) {
                    sendSignal(targetUid, { ice: event.candidate });
                }
            };

            pc.ontrack = event => {
                console.log(`Received remote track from ${targetUid}`);
                let remoteAudio = document.getElementById(`audio-${targetUid}`);
                if (!remoteAudio) {
                    remoteAudio = document.createElement('audio');
                    remoteAudio.id = `audio-${targetUid}`;
                    remoteAudio.autoplay = true;
                    remoteAudiosContainer.appendChild(remoteAudio);
                }
                remoteAudio.srcObject = event.streams[0];
            };

            if (isInitiator) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                sendSignal(targetUid, { sdp: pc.localDescription });
            }
        }

        function listenForSignals() {
            const signalsCollection = collection(db, "Lobbys list", lobbyId, "webrtc_signals", currentUser.uid, "messages");
            onSnapshot(signalsCollection, (snapshot) => {
                snapshot.docChanges().forEach(async change => {
                    if (change.type === "added") {
                        const message = change.doc.data();
                        const senderUid = message.senderUid;

                        // Ensure peer connection exists (callee side)
                        if (!peerConnections[senderUid]) {
                            createPeerConnection(senderUid, false);
                        }
                        
                        const pc = peerConnections[senderUid];

                        if (message.sdp) {
                            await pc.setRemoteDescription(new RTCSessionDescription(message.sdp));
                            if (message.sdp.type === 'offer') {
                                const answer = await pc.createAnswer();
                                await pc.setLocalDescription(answer);
                                sendSignal(senderUid, { sdp: pc.localDescription });
                            }
                        } else if (message.ice) {
                            await pc.addIceCandidate(new RTCIceCandidate(message.ice));
                        }
                        
                        // Delete signal after processing
                        await deleteDoc(change.doc.ref);
                    }
                });
            });
        }
        
        async function sendSignal(targetUid, data) {
            const signalData = { ...data, senderUid: currentUser.uid };
            await addDoc(collection(db, "Lobbys list", lobbyId, "webrtc_signals", targetUid, "messages"), signalData);
        }

        async function cleanupWebRTC() {
            // Close all peer connections
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};

            // Stop local media tracks
            if(localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Delete my signaling documents from Firestore
            const mySignalsRef = collection(db, "Lobbys list", lobbyId, "webrtc_signals", currentUser.uid, "messages");
            // This is a bit more complex to delete a whole collection client-side, but for now we leave it
            // A cloud function would be better for cleanup.
        }
        
        // --- Modal & Utility Functions (mostly unchanged) ---
        function showConfirmModal(title, message, onConfirm) { /* ... */ }
        function showNotificationModal(title, message, onOk) { /* ... */ }
        function cleanupAndRedirect() {
             if (unsubscribeLobby) unsubscribeLobby();
             cleanupWebRTC();
             window.location.href = './Lobby page.html';
        }

        // Initialize the app
        main();
        
    </script>
</body>
</html>
